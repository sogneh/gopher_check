//-----------------------------------------------------------------------------------
// ♛ GopherCheck ♛
// Copyright © 2014 Stephen J. Lovell
//-----------------------------------------------------------------------------------

package main

// Zobrist Hashing -
// Each possible square and piece combination is assigned a unique 64-bit integer key at startup.
// A unique hash key for a chess position can be generated by merging (via XOR) the keys for each
// piece/square combination, and merging in keys representing the side to move, castling rights,
// and any en-passant target square.
var pawn_zobrist_table [2][64]uint32
var zobrist_table [2][8][64]uint64 // keep array dimensions powers of 2 for faster array access.
var enp_table [65]uint64           // integer keys representing the en-passant target square, if any.
var castle_table [16]uint64
var side_key64 uint64 // keys representing a change in side-to-move.

func setup_zobrist() {
	rng := NewRngKiss(148) // sparsely populated rands produce fewer collisions.
	for c := 0; c < 2; c++ {
		for sq := 0; sq < 64; sq++ {
			pawn_zobrist_table[c][sq] = rng.RandomUint32(sq)
			for pc := 0; pc < 6; pc++ {
				zobrist_table[c][pc][sq] = rng.RandomUint64(sq)
			}
		}
	}
	for i := 0; i < 16; i++ {
		castle_table[i] = rng.RandomUint64((i << 2))
	}
	for sq := 0; sq < 64; sq++ {
		enp_table[sq] = rng.RandomUint64(sq)
	}
	enp_table[64] = 0
	side_key64 = rng.RandomUint64(63)
}

func zobrist(pc Piece, sq int, c uint8) uint64 {
	return zobrist_table[c][pc][sq]
}

func pawn_zobrist(sq int, c uint8) uint32 {
	return pawn_zobrist_table[c][sq]
}

func enp_zobrist(sq uint8) uint64 {
	return enp_table[sq]
}

func castle_zobrist(castle uint8) uint64 {
	return castle_table[castle]
}
