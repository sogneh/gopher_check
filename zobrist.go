//-----------------------------------------------------------------------------------
// ♛ GopherCheck ♛
// Copyright © 2014 Stephen J. Lovell
//-----------------------------------------------------------------------------------

package main

// Zobrist Hashing -
// Each possible square and piece combination is assigned a unique 64-bit integer key at startup.
// A unique hash key for a chess position can be generated by merging (via XOR) the keys for each
// piece/square combination, and merging in keys representing the side to move, castling rights,
// and any en-passant target square.
var pawnZobristTable [2][64]uint32
var zobristTable [2][8][64]uint64 // keep array dimensions powers of 2 for faster array access.
var enpTable [65]uint64           // integer keys representing the en-passant target square, if any.
var castleTable [16]uint64
var sideKey64 uint64 // keys representing a change in side-to-move.

func setupZobrist() {
	rng := NewRngKiss(148) // sparsely populated rands produce fewer collisions.
	for c := 0; c < 2; c++ {
		for sq := 0; sq < 64; sq++ {
			pawnZobristTable[c][sq] = rng.RandomUint32(sq)
			for pc := 0; pc < 6; pc++ {
				zobristTable[c][pc][sq] = rng.RandomUint64(sq)
			}
		}
	}
	for i := 0; i < 16; i++ {
		castleTable[i] = rng.RandomUint64((i << 2))
	}
	for sq := 0; sq < 64; sq++ {
		enpTable[sq] = rng.RandomUint64(sq)
	}
	enpTable[64] = 0
	sideKey64 = rng.RandomUint64(63)
}

func zobrist(pc Piece, sq int, c uint8) uint64 {
	return zobristTable[c][pc][sq]
}

func pawnZobrist(sq int, c uint8) uint32 {
	return pawnZobristTable[c][sq]
}

func enpZobrist(sq uint8) uint64 {
	return enpTable[sq]
}

func castleZobrist(castle uint8) uint64 {
	return castleTable[castle]
}
